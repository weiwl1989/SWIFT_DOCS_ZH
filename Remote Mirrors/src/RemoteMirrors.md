
原文地址：https://github.com/apple/swift/blob/main/docs/proposals/RemoteMirrors.rst

# Remote Mirrors

### Remote mirrors 提议

这个方案描述了一种具名类型（Nominal Type, 区别于 Structural Type）元数据的新实现，它将支持进程外堆检查，可用于内存测试工具检测循环引用导致的内存泄露。 该实现将合入对Mirrors的现有反射支持，从而可以在进程外使用，同时还减少了生成的二进制文件大小。

跟踪这个工作的的 Radars:
- rdar://problem/15617914
- rdar://problem/17019505
- rdar://problem/20771693

### 目标和非目标

我们希望在Swift项目中对内存分配进行事后调试(post-mortem debugging)。调试工具已经可以对内存分配器进行内部检查，以识别在程序堆中的所有实时内存(live memory)分配。

如果编译器要发出(emit)必要的元数据，可以确定大多数分配的布局(layout)，特别是我们可以识别堆对象内的任何引用。该元数据可以和程序的核心转储(the core dump)一起使用，以构建对象图(graph of objects)。

我们必须能获得所有必要的信息，而无需在目标的地址空间中执行任何代码，因为它可能已经释放了，或者处于funny state。
为了识别循环引用，我们需要知道每一个引用是强引用，弱引用还是无主引用（unowned）。

我们希望能够选择不使用元数据。为了保密，我们可能想要删除字段名，但保留了字段中包含了引用的元数据。对于发布的版本，我们可能希望完全删除大多数字段元数据，除非明确依赖反射功能的代码。

最好是新功能中包含一些现有元数据，而不是添加保持编译器和运行时同步的一组全新结构。

虽然在不使用时运行时开销为零，但如果自我检查需要一些额外的计算，尤其是在可以预加载或者缓存时。

极少数情况下，元数据允许不精确 - 对于某些分配，我们可能无法确定包含的值的运行时类型。同样，我们也不会尝试通过遍历指针的栈来验证对象图的"roots"。

### 堆分配的类型

Swift 中有几种类型的堆分配。目前，我们最关心的是类实例，但在时间充裕时，我们希望为所有的堆提供准确的元数据。

#### Swift 类型实例

它们具有一个指向类元数据记录(class metadata record)的 isa 指针。

#### Objective-C 类型实例

它们也有一个 同样的 isa 指针，但类元数据记录中设置了 Objective-C 集合(set) 。

#### Boxes

这些被用于堆分配的在闭包中捕获的可变值、用于递归枚举和Error existential values。它们有一个可以识别的isa 指针和引用计数，但 isa 指针由所有boxes共享，因此不能描述box的堆布局(the heap layout)。

#### Contexts

厚函数的context的布局就像由捕获值组成的元组一样。当前，运行时所需的布局的唯一方面是知道哪些捕获值是堆指针。在这里在每个可能的布局创建一个唯一的isa指针。

#### Blocks

Blocks 与Contexts相似，但是具有common header，并且将函数指针和捕获值 打包在单个可保留堆对象中。

#### Metatypes

运行时分配的元类型将出现在malloc堆中，尽管它们本身不能包含堆引用。

#### 不透明值缓冲区

当值太大而无法放入存在的内联存储时就会出现这种情况，例如，因为他们没有 header，因此我们一开始就不会尝试对其进行自我检查 --直到我们可以识别指向在堆内存分配对象本身存在的缓存区的指针。

#### Existing metadata

Swift已经具有很多反射功能，并且许多基础工作都以某种形式存在，但是每一个都至缺少一个重要方面(respect)。

#### 泛型类元数据（Generic type metadata）

对象的isa指针指向一个元数据记录实例。对于泛型类类型的实例，元数据是从泛型元数据模版和绑定到泛型参数的具体类型一起被延迟实例化的。

为了具有活动实例的泛型类和源代码显式引用的值类型元数据记录，泛型类元数据被实例化。

当编译器需要发出泛型类元数据记录时，它会根据所引用的类型使用几种策略之一。对于具体的非泛型类型，可以生成对延迟访问器的直接调用。 对于绑定的泛型T <P1，...，Pn>，我们为泛型参数Pn递归地发出元数据引用，然后调用绑定类型T的getter。 对于原型-也就是说，泛型类参数是正在编译的函数体内的自由变量-元数据作为值传递，因此编译器仅发出该副本。

泛型类元数据告诉我们每个堆分配的大小，但本身并不能告诉我们字段的类型或它们包含哪些引用。

#### Mirrors and NominalTypeDescriptors
Mirrors的实现使用运行时原语(primitives)，该原语通过查看嵌入在类型元数据记录中的NominalTypeDescriptor来检查不透明值的字段。

对于结构和类，NominalTypeDescriptor包含一个函数指针，该指针返回一个field types 的数组。函数指针指向编译器发出的“field type 元数据函数”。 这个函数针对每种字段类型发出元数据记录引用，并将它们收集在数组中。由于类实例的isa指针指向实例化类型， 这样NominalTypeDescriptor的field types 也都是具体类型。

NominalTypeDescriptors除记录类型外，还记录字段名称。现在，所有这些信息都存储在一起，而没有任何方式将它剥离。另外，NominalTypeDescriptors不会记录引用是强引用，弱引用还是无主引用，但这很容易修复。

更大的问题是，我们必须调用一个函数来延迟生成字段类型元数据。尽管在崩溃的进程中会出现每个实例化类类型的NominalTypeDescriptor，但字段类型却不会，因为只有对字段类型函数的调用才会实例化它们。

#### Objective-C 实例变量元数据
Objective-C运行时跟踪类的实例变量的类型，并且这里有足够的信息来标识在具体类型的实例中的指针，但是不支持泛型类型。我们可以让泛型类型的泛型类型元数据实例化也复制并填写Objective-C实例变量的模板，但这会给主要用于调试的功能增加运行时成本。

#### DWARF metadata
IRGen会为非泛型类型发出最少数量的DWARF元数据，但不会尝试以这种方式向调试器描述泛型类型布局。

但是，DWARF的优点是可以在不运行代码的情况下对其进行自我检查，然后将其删除。

### 新的字段类型元数据格式
以上所有方面的主要局限性是无法推理泛型类型，或者是要求在target中运行代码。

假设T是一个泛型类型，而S是一些替换集。

编译器从概念上实现了一个操作G（T，S），该操作返回给定输入参数的懒加载类型描述符。但是，它实际上执行部分求值 G(T)(S)，而“G(T)”部分发生在编译时执行。

类似地，我们可以将字段类型访问函数视为操作F(T, S)，该操作返回T的字段类型，而T再次在编译时修复。

我们在这里真正想要的是构建一个“解释器”，或者实际上是一个简单的序列化图的解析器，它了解如何解析未实例化的泛型元数据，跟踪替换以及计算字段的偏移量，大小和引用的位置。

该“解释器”必须能够“从头开始”查找叶类型的元数据，并以与泛型类型元数据实例化计算对象大小相同的方式计算字段大小和偏移量。

“解释器”将采用库的形式，用于了解字段类型元数据记录和符号类型引用。这将是一个C ++库，它需要支持以下用例：

  1. 进程内反射，用于支持标准库中的当前镜像
  2. 进程外反射，用于堆调试工具
  3. 进程外反射，用于库中的新remote Mirrors功能（可选）
  
这个API将类似于mirrors，因为他们现在在stdlib中。

详情如下所述。

#### 符号类型引用
由于我们操作未实例化的泛型元数据，所以我们需要某种方法来描述类型的组合。我们使用用迷你语言编写的类型引用，代替使用现在不够用的元数据记录指针。

符号类型引用是一种递归结构，根据标称类型、泛型类型参数及其组合（如元组类型）来描述任意 Swift AST 类型。

对于每种 AST 类型，我们可以区分需要识别其中堆引用的最小信息，以及用于反射的完整类型。前者可以保留，而后者可以在某些版本中删除。

我们已经有一个非常相似的编码 —— 在 SIL 中参数类型mangling。最好重新使用此编码，但为了完整，类型引用的完整格式如下所述：

1. ***内置类型引用*** 特殊 tokens 可用于引用具有运行时支持的各种内置类型。
2. ***具体类型引用*** 既可以是类型的mangled name， 也可以是target的GOT偏移。
3. ***堆引用*** 这包括:
    - strong, weak or unowned
    - (可选) 对类类型本身的引用
4. ***绑定泛型类型*** 这包括:
    - 具体的或内置的类型引用
    - 每个泛型参数的嵌套符号类型引用
5. ***元组类型*** 这包括:
    - 符号类型引用的递归序列
6. ***函数类型***。 这包括:
    - A representation,
    - (可选) 输入和输出类型
7. ***协议组合类型*** 这包括:
    - A flag indicating if any of the protocols are class-constrained, which changes the representation
    - 组合中的非 @objc 协议的数量
    - (可选) 对组合中所有协议的引用
8. ***元类型*** 这包括:
    - (可选) 对实例类型的类型引用
    - 没有必须的信息 -- 元类型始终是指向堆对象的单个指针，该堆对象本身不引用任何其他堆对象。
9. ***存在的元类型*** 这包括:
    - 组合中的协议数。
    - (可选) 对协议成员的类型引用。
10. ***泛型参数*** 在泛型类型的字段类型中,可以出现对泛型类型的引用。 泛型参数在这里由索引唯一标识 (一旦添加嵌套泛型类型, 则为深度)。
你可以将类型引用可视化为就好像他们是用 S 表达式格式编写一样 ， 但实际上，它将以紧凑的二进制形式序列化：

```
(tuple_type
  (bound_generic_type
    (concrete_type "Array")
    (concrete_type "Int"))
  (bound_generic_type
    (builtin_type "Optional")
    (generic_type_parameter_type index=0)))
```

我们将提供一个用于解码，编码和操作符号类型引用的standalone routines库。

#### 字段类型元数据记录

我们引入了一个新的元数据类型，存储在其自己的部分中，以便可以将其剥离，称为"字段类型元数据"。对于每种标称类型，我们发出包含以下内容的记录：

1. 标称类型的名称，
2. 泛型参数的数量，
3. 类型引用，以上面的迷你语言编写，用于每种字段类型。
4. 字段名称（如果启用）。

字段类型元数据是链接在一起的，以便可以通过名称进行搜索和通过内部检查核心转储进行post-mortem 。

我们添加一个新的字段到 NominalTypeDescriptor 中， 以存储指向此标称类型的字段类型元数据的指针。 在包含这个字段的 "new-style" 的 NominalTypeDescriptors 中，现有字段类型函数将指向在运行时定义的通用字段类型函数，它实例化字段类型元数据。 如果需要，允许向后兼容老代码。

#### 字段类型元数据实例化
首先， 在target中给一个 isa 指针，我们需要通过从实例化元数据向后移动到未实例化元数据，收集泛型参数来构建符号类型引用。此操作是 lazy ，缓存每个 isa 指针的结果。

```
enum SymbolicTypeReference {
  case Concrete(String)
  case BoundGeneric(String, [SymbolicTypeReference])
  case Tuple([SymbolicTypeReference])
  ...
}

func getSymbolicTypeOfObject(_ isa: void*) -> SymbolicTypeReference
```

接下来，我们定义一个"instantiation"操作，该操作采用完全替换的符号类型引用，并返回具体字段类型和偏移量的列表。
此操作需要递归访问字段元数据记录并跟踪泛型参数替换，以便正确计算所有字段偏移量和大小。

可以缓存每个给定的 SymbolicTypeReference 的实例化元数据的结果，以便更快地查找。

这个库在跟踪target中的任何指针时必须小心，恰当地处理部分初始化对象，导致内存损坏的运行时错误或者恶意代码，否则会崩溃或者调用调试工具。

```
enum FieldLayout {
  // the field contains a heap reference
  case Strong, Weak, Unowned
  // the field is an opaque binary blob, contents unknown.
  case Opaque
  // the field is a value type -- look inside recursively.
  case ValueType(indirect field: FieldDescriptor)
}

struct FieldDescriptor {
  let size: UInt
  let align: UInt
  let offset: UInt
  let layout: FieldLayout
}

func instantiateSymbolicType(_ ref: SymbolicTypeReference) -> [FieldTypeDescriptor]
```

字段类型元数据可以具有循环引用 -- 例如，考虑两个互相包含的类。为了正确地计算字段偏移量，当我们知道某个类是类类型时中断循环，并使用工作列表算法(work-list algorithm)而不是无限递归来确保继续进行。

#### 枚举类型元数据
对于枚举，字段元数据记录还需要包含有关有效负载类型的备用位和标记位的足够信息，这样我们可以在运行时确定重载的大小写并预测有效负载，这样又可以在target中运行代码。

这将使我们能够删除纯粹为反射而生成的一对vaule witness functions，因为它们好像并不对性能至关重要。

#### 闭包
对于 对于闭包上下文 和 blocks, 最好也发布元数据。

#### 保密和发布构建

我们可以选择几个级别的元数据发布

1. 对于出于功能目的需要运行时的代码，或者对于调试版本中的标准库，我们可以有协议一致性或编译器标志启用所有元数据无条件释放。
2. 对于系统框架，我们可以省略字段名称，用唯一标识符替换类名，但保留类型元数据以帮助用户调试内存泄漏，其中框架类保留用户类的实例。
3. 对于发布版本，我们可以删除所有元数据，除非在 1 中明确要求）。

这可能需要将所需的元数据放在与调试元数据不同的部分中。也许字段名称也应该与符号类型引用分开。

#### 性能
由于字段类型元数据实例化每个 isa 指针只发生一次，所以 mirrors 不会在初始预热时间(the initial warm-up time)之后受到性能影响。一旦 field type descriptor 被构造之后，字段的反射访问将如之前一样继续进行。

从文本段(text segment)中移除所有字段类型的函数可能会带来边际性能提升，因为这些函数目前与其他代码混杂在一起，用不包含任何重定位的只读数据替换它们，直到被需要的时候才调用这些函数。

#### Resilience
在稳定 ABI 后我们可能会选择实现新的元数据facility。在这种情况下，我们应该首先在 NominalTypeDescriptors进行预加载一些工程工作，使其更易于将来的扩展。

我们需要仔细检查新的元数据格式，并确保它足够足够灵活以便支持未来的语言特性，如绑定泛型存在，这可能进一步使堆布局复杂化。

如上所述，可以向后兼容的方式引入这样的更改。我们将字段类型函数字段保留在 NominalTypeDescriptor 中，但对于"new-style"记录，将它设置为指向在运行时定义的公共函数，该函数解析新元数据并返回一个可由旧客户端使用的字段类型的数组。

#### 测试
通过transitioning mirrors来使用新的元数据，通过已有的测试来校验behavior。开发其他测试来执行各种分配和断言生成对象图的属性(无论来自进程内还是进程外)。

如果我们采用同时具有字段类型的函数和字段类型元数据的渐进方法，我们还可以实例化前者，并将其与调用后者的结果进行比较，对于系统中的所有类型，作为验证字段类型元数据的一种方法。



